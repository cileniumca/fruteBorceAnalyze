using AnalyzeDomains.Domain.Enums;
using AnalyzeDomains.Domain.Interfaces.Analyzers;
using AnalyzeDomains.Domain.Interfaces.Services;
using AnalyzeDomains.Domain.Models.AnalyzeModels;
using AnalyzeDomains.Infrastructure.Analyzers;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;

namespace AnalyzeDomains.Infrastructure.Services
{
    /// <summary>
    /// Comprehensive WordPress plugin vulnerability scanner service.
    /// This service demonstrates educational security testing techniques for research purposes only.
    /// Implementation is thread-safe and designed for concurrent operation with rate limiting.
    /// </summary>
    public class WordPressVulnerabilityResearchService
    {
        private readonly IWordPressPluginVulnerabilityAnalyzer _vulnerabilityAnalyzer;
        private readonly AdvancedWordPressExploitAnalyzer _advancedAnalyzer;
        private readonly IDatabaseService _databaseService;
        private readonly ILogger<WordPressVulnerabilityResearchService> _logger;
        
        // Thread-safe collections for concurrent analysis
        private readonly ConcurrentDictionary<string, VulnerabilityAnalysisSession> _activeSessions = new();
        private readonly SemaphoreSlim _concurrentAnalysisLimiter;
        
        // Rate limiting for responsible testing
        private readonly SemaphoreSlim _rateLimiter;
        private readonly TimeSpan _analysisDelay = TimeSpan.FromSeconds(2);

        public WordPressVulnerabilityResearchService(
            IWordPressPluginVulnerabilityAnalyzer vulnerabilityAnalyzer,
            AdvancedWordPressExploitAnalyzer advancedAnalyzer,
            IDatabaseService databaseService,
            ILogger<WordPressVulnerabilityResearchService> logger)
        {
            _vulnerabilityAnalyzer = vulnerabilityAnalyzer;
            _advancedAnalyzer = advancedAnalyzer;
            _databaseService = databaseService;
            _logger = logger;
            
            // Limit concurrent analysis to prevent overwhelming targets
            _concurrentAnalysisLimiter = new SemaphoreSlim(Environment.ProcessorCount, Environment.ProcessorCount);
            _rateLimiter = new SemaphoreSlim(5, 5); // Max 5 concurrent rate-limited operations
        }

        /// <summary>
        /// Performs comprehensive vulnerability analysis on a WordPress site.
        /// Includes both detection and educational testing of vulnerabilities.
        /// </summary>
        public async Task<VulnerabilityAnalysisResult> PerformComprehensiveAnalysisAsync(
            string url, 
            int siteId,
            string attackerIp = "127.0.0.1",
            int attackerPort = 4444,
            CancellationToken cancellationToken = default)
        {
            var sessionId = Guid.NewGuid().ToString("N")[..8];
            var session = new VulnerabilityAnalysisSession
            {
                SessionId = sessionId,
                TargetUrl = url,
                SiteId = siteId,
                StartTime = DateTime.UtcNow
            };

            _activeSessions[sessionId] = session;
            
            try
            {
                await _concurrentAnalysisLimiter.WaitAsync(cancellationToken);
                _logger.LogInformation("Starting comprehensive vulnerability analysis for {Url} (Session: {SessionId})", url, sessionId);

                var result = new VulnerabilityAnalysisResult
                {
                    TargetUrl = url,
                    SiteId = siteId,
                    SessionId = sessionId,
                    StartTime = session.StartTime
                };

                // Phase 1: General vulnerability detection
                await _rateLimiter.WaitAsync(cancellationToken);
                try
                {
                    result.GeneralVulnerabilities = await _vulnerabilityAnalyzer.AnalyzeVulnerabilitiesAsync(url, cancellationToken);
                    session.Phase = "General Analysis Complete";
                }
                finally
                {
                    _rateLimiter.Release();
                }

                await Task.Delay(_analysisDelay, cancellationToken);

                // Phase 2: Advanced analysis with educational techniques
                await _rateLimiter.WaitAsync(cancellationToken);
                try
                {
                    result.AdvancedVulnerabilities = await _advancedAnalyzer.AnalyzeVulnerabilitiesAsync(url, cancellationToken);
                    session.Phase = "Advanced Analysis Complete";
                }
                finally
                {
                    _rateLimiter.Release();
                }

                await Task.Delay(_analysisDelay, cancellationToken);

                // Phase 3: Educational exploit testing (only if vulnerabilities found)
                if (result.GeneralVulnerabilities.Any() || result.AdvancedVulnerabilities.Any())
                {
                    result.ExploitResults = await PerformEducationalExploitTestsAsync(url, attackerIp, attackerPort, cancellationToken);
                    session.Phase = "Educational Testing Complete";
                }

                // Phase 4: Save results to database
                await SaveAnalysisResultsAsync(result, cancellationToken);
                session.Phase = "Results Saved";

                result.EndTime = DateTime.UtcNow;
                result.Duration = result.EndTime - result.StartTime;
                result.Success = true;

                _logger.LogInformation("Comprehensive analysis completed for {Url}. Found {VulnCount} vulnerabilities in {Duration:mm\\:ss}",
                    url, result.TotalVulnerabilityCount, result.Duration);

                return result;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during comprehensive analysis for {Url} (Session: {SessionId})", url, sessionId);
                
                return new VulnerabilityAnalysisResult
                {
                    TargetUrl = url,
                    SiteId = siteId,
                    SessionId = sessionId,
                    StartTime = session.StartTime,
                    EndTime = DateTime.UtcNow,
                    Success = false,
                    ErrorMessage = ex.Message
                };
            }
            finally
            {
                _concurrentAnalysisLimiter.Release();
                _activeSessions.TryRemove(sessionId, out _);
            }
        }

        /// <summary>
        /// Performs educational exploit testing for research purposes.
        /// All tests are designed to be safe and educational only.
        /// </summary>
        private async Task<List<VulnerabilityExploitResult>> PerformEducationalExploitTestsAsync(
            string url, 
            string attackerIp, 
            int attackerPort, 
            CancellationToken cancellationToken)
        {
            var exploitResults = new List<VulnerabilityExploitResult>();

            _logger.LogInformation("Starting educational exploit testing for {Url}", url);

            // Test 1: Reflex Gallery Upload (Educational)
            try
            {
                await _rateLimiter.WaitAsync(cancellationToken);
                var reflexResult = await _advancedAnalyzer.TestReflexGalleryUploadAsync(url, attackerIp, attackerPort, cancellationToken);
                exploitResults.Add(reflexResult);
                _rateLimiter.Release();
                await Task.Delay(_analysisDelay, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Reflex Gallery test failed for {Url}", url);
                _rateLimiter.Release();
            }

            // Test 2: Gwolle Guestbook RFI (Educational)
            try
            {
                await _rateLimiter.WaitAsync(cancellationToken);
                var gwolleResult = await _advancedAnalyzer.TestGwolleGuestbookRfiAsync(url, attackerIp, attackerPort, cancellationToken);
                exploitResults.Add(gwolleResult);
                _rateLimiter.Release();
                await Task.Delay(_analysisDelay, cancellationToken);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Gwolle Guestbook test failed for {Url}", url);
                _rateLimiter.Release();
            }

            // Test 3: Mail Masta LFI (Educational)
            try
            {
                await _rateLimiter.WaitAsync(cancellationToken);
                var mailMastaResult = await _advancedAnalyzer.TestMailMastaLfiAsync(url, attackerIp, attackerPort, cancellationToken);
                exploitResults.Add(mailMastaResult);
                _rateLimiter.Release();
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Mail Masta test failed for {Url}", url);
                _rateLimiter.Release();
            }

            _logger.LogInformation("Educational exploit testing completed for {Url}. {TestCount} tests performed", 
                url, exploitResults.Count);

            return exploitResults;
        }

        /// <summary>
        /// Saves analysis results to the database in a thread-safe manner.
        /// </summary>
        private async Task SaveAnalysisResultsAsync(VulnerabilityAnalysisResult result, CancellationToken cancellationToken)
        {
            try
            {
                // Combine all vulnerabilities
                var allVulnerabilities = new List<PluginVulnerability>();
                allVulnerabilities.AddRange(result.GeneralVulnerabilities);
                allVulnerabilities.AddRange(result.AdvancedVulnerabilities);

                // Save vulnerabilities if any found
                if (allVulnerabilities.Any())
                {
                    await _databaseService.InsertSiteVulnerabilitiesAsync(result.SiteId, allVulnerabilities, cancellationToken);
                    _logger.LogInformation("Saved {Count} vulnerabilities to database for site {SiteId}", 
                        allVulnerabilities.Count, result.SiteId);
                }

                // Save exploit results if any performed
                if (result.ExploitResults.Any())
                {
                    await _databaseService.InsertVulnerabilityExploitResultsAsync(result.SiteId, result.ExploitResults, cancellationToken);
                    _logger.LogInformation("Saved {Count} exploit test results to database for site {SiteId}", 
                        result.ExploitResults.Count, result.SiteId);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to save analysis results for site {SiteId}", result.SiteId);
                // Don't rethrow - analysis was successful even if saving failed
            }
        }

        /// <summary>
        /// Gets the status of all active analysis sessions.
        /// </summary>
        public Dictionary<string, VulnerabilityAnalysisSession> GetActiveSessionsStatus()
        {
            return _activeSessions.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
        }

        /// <summary>
        /// Performs a quick vulnerability scan without exploit testing.
        /// Suitable for large-scale analysis.
        /// </summary>
        public async Task<List<PluginVulnerability>> PerformQuickScanAsync(string url, CancellationToken cancellationToken = default)
        {
            await _concurrentAnalysisLimiter.WaitAsync(cancellationToken);
            try
            {
                await _rateLimiter.WaitAsync(cancellationToken);
                var vulnerabilities = await _vulnerabilityAnalyzer.AnalyzeVulnerabilitiesAsync(url, cancellationToken);
                _rateLimiter.Release();
                
                _logger.LogInformation("Quick scan completed for {Url}. Found {Count} vulnerabilities", 
                    url, vulnerabilities.Count);
                
                return vulnerabilities;
            }
            finally
            {
                _concurrentAnalysisLimiter.Release();
            }
        }

        /// <summary>
        /// Disposes of resources used by the service.
        /// </summary>
        public void Dispose()
        {
            _concurrentAnalysisLimiter?.Dispose();
            _rateLimiter?.Dispose();
        }
    }

    /// <summary>
    /// Represents the result of a comprehensive vulnerability analysis.
    /// </summary>
    public class VulnerabilityAnalysisResult
    {
        public string TargetUrl { get; set; } = string.Empty;
        public int SiteId { get; set; }
        public string SessionId { get; set; } = string.Empty;
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public TimeSpan Duration { get; set; }
        public bool Success { get; set; }
        public string? ErrorMessage { get; set; }
        public List<PluginVulnerability> GeneralVulnerabilities { get; set; } = new();
        public List<PluginVulnerability> AdvancedVulnerabilities { get; set; } = new();
        public List<VulnerabilityExploitResult> ExploitResults { get; set; } = new();
        
        public int TotalVulnerabilityCount => GeneralVulnerabilities.Count + AdvancedVulnerabilities.Count;
        public int SuccessfulExploitCount => ExploitResults.Count(r => r.Success);
    }

    /// <summary>
    /// Represents an active vulnerability analysis session.
    /// </summary>
    public class VulnerabilityAnalysisSession
    {
        public string SessionId { get; set; } = string.Empty;
        public string TargetUrl { get; set; } = string.Empty;
        public int SiteId { get; set; }
        public DateTime StartTime { get; set; }
        public string Phase { get; set; } = "Starting";
        public TimeSpan ElapsedTime => DateTime.UtcNow - StartTime;
    }
}
